# -*- coding: utf-8 -*-
"""version_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k2kfA61_yaijHR1qR5f8SVgJ43TBj78-
"""

import nltk
nltk.download('stopwords')
# importing pandas package
import re
from nltk.corpus import stopwords
import liste as ls
import numpy as np
import math as ma
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn import svm

freq_words = []
freq_emojis = []
X = []


les_mot = []
matrix = []
ligne_mot = []
ligne_mots = []
nb_occurence = 0

for mot in ls.emojis_negative:
    freq_emojis.append(mot)


for mot in ls.emojis_positive:
    freq_emojis.append(mot)


stopwords_list = stopwords.words('arabic')

file = open("com15.csv", "r")
lines = file.readlines()
target = np.zeros((len(lines)) , dtype='i')
i = 0
for line in lines:
    vector = []
    mots_Commentaire = line.strip()
    if "pos" in (mots_Commentaire):
        target[i] = 1
    for word in freq_emojis:
        if word in mots_Commentaire :
            vector.append(1)
        else:
            vector.append(0)
    i+= 1
    X.append(vector)


file.close()


print("la partie des émojis est fini")

file = open("com15.csv", "r")
lines = file.readlines()
for line in lines :
    mots_Commentaire = re.findall(r'[أ-ي]+', line)
    mots_no_stop = []
    for mo in mots_Commentaire:
        if mo not in  stopwords_list  and mo not in  les_mot :
            les_mot.append(mo)



file.close()



for mot in les_mot:
    ligne_mot.append(mot)

matrix.append(ligne_mot)


test_idf = np.zeros((len(matrix[0])) , dtype='i')

print('la construction de copus est fini')
print(len(matrix[0]))
file = open("com15.csv", "r")
lines = file.readlines()
for line in lines:
    mots_Commentaire = re.findall(r'[أ-ي]+', line)
    ligne_mots = []
    for Mot_Matrice in matrix[0]:
        nb_occurence = 0
        for mot in mots_Commentaire:
            if mot == Mot_Matrice:
                nb_occurence +=1
        if nb_occurence != 0:
          test_idf[matrix[0].index(Mot_Matrice)] += 1
        if   len(mots_Commentaire) > 0 :
          ligne_mots.append(nb_occurence/len(mots_Commentaire))
        else:
          ligne_mots.append(0)

    matrix.append(ligne_mots)


print("la partie TF est fini")

vecteur_idf = []
nb_commentaire = len(lines)

for j in range(len(test_idf)):
    vecteur_idf.append(ma.log10(nb_commentaire / test_idf[j]))


print("la phase de idf est terminée")

nb_colonne  = len(matrix[0])
for j in range(i):
  for z in range(nb_colonne):
        matrix[j + 1][z] =  vecteur_idf[z] * matrix[j+1][z]


print('la partie de idf * tf est fini ')


del matrix[0]
matrixe = []
nb_ligne = len(lines)
for h in range(nb_ligne):
    matrixe.append(matrix[h] + X[h])


print("le multiplixage est fiin")


del matrix
del X

data_test = train_test_split(matrixe, target
                                 , random_state=0
                                 , train_size=0.75)

data_train, data_test, target_train, target_test = data_test


clf = svm.SVC()

print('le modale a commencé a fonctioné')
clf.fit(data_train, target_train)



result = clf.predict(data_test)

print(accuracy_score(result, target_test))